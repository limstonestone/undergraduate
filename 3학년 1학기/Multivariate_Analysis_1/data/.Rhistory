pcfa$r.scores
### Q3) 인자점수그림을 통해 형성된 군집의 특성을 살펴보라.
fpc = pcfa_rotate$scores
fpc
### Q3) 인자점수그림을 통해 형성된 군집의 특성을 살펴보라.
fpc = pcfa$scores
fpc
mlfa = factanal(R, factors=3)
mlfa = factanal(R, factors=2)
Z = scale(X, scale=T)
mlfa = factanal(Z, factors=2)
mlfa = factanal(Z, factors=3)
### Q3) 인자점수그림을 통해 형성된 군집의 특성을 살펴보라.
fpc = pcfa$score
lim = range(pretty(L))
par(mfrow=c(2,2))
par(family="AppleGothic")
plot(L[,1], L[,2],main="Plot of Factor Loadings(f1 & f2) : none ",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(L[,1], L[, 2], labels=rownames(L), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L[,1], L[, 2], col=2, code=2, length=0.1)
plot(L[,1], L[,3],main="Plot of Factor Loadings(f1 & f3) : none ",  xlab="f1", ylab="f3",
xlim=lim, ylim=lim)
text(L[,1], L[, 3], labels=rownames(L), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L[,1], L[, 3], col=2, code=2, length=0.1)
plot(L[,2], L[,3],main="Plot of Factor Loadings(f2 & f3) : none ",  xlab="f2", ylab="f3",
xlim=lim, ylim=lim)
text(L[,2], L[, 3], labels=rownames(L), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L[,2], L[, 3], col=2, code=2, length=0.1)
pcfa_rotate = principal(R, nfactors=3, rotate="varimax")
rm(list=ls())
wd = paste(getwd(), "/Multivariate_Analysis_1/data", sep="")
setwd(wd)
getwd()
### Q1) PCFA를 실시하여 스크리그림을 통하여 인자개수를 정하고 총기여율을 구하라.
# Data Matrix X
Data = read.table("censustract.txt", header=T, fileEncoding="euc-kr")
X = Data
p = ncol(X)
# Correlation Matrix R
R = cor(X)
# Spectral Decomposition (# of factor)
eigen.R = eigen(R)
gof = eigen.R$values / p*100 # Goodness-of fit
plot(eigen.R$values, type="b", main="Scree Graph", xlab="Factor Number", ylab="Eigenvalue")
round(gof, 3)
39.838 + 27.351
### Q2) 인자적재값과 인자적재그림을 통하여 인자를 해석하라.
library(psych)
Z = scale(R, scale=T)
pcfa = principal(Z, nfactors=3, rotate="none")
pcfa = principal(Z, nfactors=2, rotate="none")
### Q2) 인자적재값과 인자적재그림을 통하여 인자를 해석하라.
library(psych)
Z = scale(X, scale=T)
pcfa = principal(Z, nfactors=2, rotate="none")
L = pcfa$loading[, 1:2]
round(L, 3)
Psi = pcfa$uniquenesses
Rm = R -(L %*% t(L) + diag(Psi))
round(Rm, 3)
pcfa
Psi = pcfa$uniquenesses
Rm = R -(L %*% t(L) + diag(Psi))
round(Rm, 3)
pcfa
lim = range(pretty(L))
par(mfrow=c(2,2))
par(family="AppleGothic")
plot(L[,1], L[,2],main="Plot of Factor Loadings(f1 & f2) : none ",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
dev.off()
par(family="AppleGothic")
plot(L[,1], L[,2],main="Plot of Factor Loadings(f1 & f2) : none ",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(L[,1], L[, 2], labels=rownames(L), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L[,1], L[, 2], col=2, code=2, length=0.1)
pcfa_rotate = principal(Z, nfactors=3, rotate="varimax")
L_rotate = pcfa_rotate$loading[, 1:3]
round(L_rotate, 3)
lim = range(pretty(L_rotate))
pcfa_rotate = principal(Z, nfactors=3, rotate="varimax")
L_rotate = pcfa_rotate$loading[, 1:3]
round(L_rotate, 3)
lim = range(pretty(L_rotate))
par(family="AppleGothic")
plot(L_rotate[,1], L_rotate[,2],main="Plot of Factor Loadings(f1 & f2) : varimax ",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
pcfa_rotate = principal(Z, nfactors=2, rotate="varimax")
L_rotate = pcfa_rotate$loading[, 1:2]
round(L_rotate, 3)
lim = range(pretty(L_rotate))
par(family="AppleGothic")
plot(L_rotate[,1], L_rotate[,2],main="Plot of Factor Loadings(f1 & f2) : varimax ",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
R
### Q3) 인자점수그림을 통해 형성된 군집의 특성을 살펴보라.
fpc = pcfa$score
round(fpc,3)
lim = range(pretty(fpc))
lim = range(pretty(fpc))
plot(fpc[,1], fpc[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(fpc[,1], fpc[,2], labels=rownames(fpc), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
lim = range(pretty(fpc))
plot(fpc[,1], fpc[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(fpc[,1], fpc[,2], labels=rownames(Z), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
### Q3) 인자점수그림을 통해 형성된 군집의 특성을 살펴보라.
fpc = pcfa$score
round(fpc,3)
lim = range(pretty(fpc))
plot(fpc[,1], fpc[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(fpc[,1], fpc[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
dev.off()
lim = range(pretty(fpc))
plot(fpc[,1], fpc[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(fpc[,1], fpc[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
fpc_rotate = pcfa_rotate$score
round(fpc_rotate)
lim_rotate = range(pretty(fpc))
plot(fpc[,1], fpc[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc[,1], fpc[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
round(fpc_rotate, 3)
fpc_rotate = pcfa_rotate$score
round(fpc_rotate, 3)
lim_rotate = range(pretty(fpc))
plot(fpc[,1], fpc[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc[,1], fpc[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
round(L_rotate, 3)
### Q3) 인자점수그림을 통해 형성된 군집의 특성을 살펴보라.
# 해석의 편리함을 위해 인자회전한 값에 대하여 인자 점수그림을 그린다.
fpc_rotate = pcfa_rotate$score
round(fpc_rotate, 3)
lim_rotate = range(pretty(fpc))
plot(fpc[,1], fpc[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc[,1], fpc[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
pcfa_rotate = principal(Z, nfactors=2, rotate="varimax")
L_rotate = pcfa_rotate$loading[, 1:2]
round(L_rotate, 3)
lim_rotate = range(pretty(L_rotate))
par(family="AppleGothic")
plot(L_rotate[,1], L_rotate[,2],main="Plot of Factor Loadings(f1 & f2) : varimax ",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
### Q3) 인자점수그림을 통해 형성된 군집의 특성을 살펴보라.
# 해석의 편리함을 위해 인자회전한 값에 대하여 인자 점수그림을 그린다.
fpc_rotate = pcfa_rotate$score
round(fpc_rotate, 3)
lim_rotate = range(pretty(fpc_rotate))
plot(fpc_rotate[,1], fpc_rotate[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc_rotate[,1], fpc_rotate[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
par(mfrow=c(1, 2))
lim_rotate = range(pretty(fpc_rotate))
plot(fpc_rotate[,1], fpc_rotate[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc_rotate[,1], fpc_rotate[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
lim_rotate = range(pretty(L_rotate))
par(family="AppleGothic")
plot(L_rotate[,1], L_rotate[,2],main="Plot of Factor Loadings(f1 & f2) : varimax ",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
X
X[45:50]
X[45:50, ]
X[45:50, ]
### Q4) (1)의 인자개수에 대해 MLFA를 실시하고 (2)~(3)을 시행한 후에 결과를 서로 비교하라.
mlfa = factanal(Z, factors=2, rotation="varimax", score="regression")
mlfa
### Q4) (1)의 인자개수에 대해 MLFA를 실시하고 (2)~(3)을 시행한 후에 결과를 서로 비교하라.
mlfa = factanal(Z, factors=2, rotation="varimax")
mlfa
Lm = mlfa$loadings[, 1:2]
round(Lm, 3)
Psi = mlfa$uniquenesses
Rm = R - (Lm %*% t(Lm) + diag(Psi))
round(Rm, 3) # Residual matrix
rm(list=ls(0))
rm(list=ls())
wd = paste(getwd(), "/Multivariate_Analysis_1/data", sep="")
setwd(wd)
### Q1) PCFA를 실시하여 스크리그림을 통하여 인자개수를 정하고 총기여율을 구하라.
# Data Matrix X
Data = read.table("censustract.txt", header=T, fileEncoding="euc-kr")
X = Data
p = ncol(X)
# Correlation Matrix R
R = cor(X)
# Spectral Decomposition (# of factor)
eigen.R = eigen(R)
gof = eigen.R$values / p*100 # Goodness-of fit
plot(eigen.R$values, type="b", main="Scree Graph", xlab="Factor Number", ylab="Eigenvalue")
round(gof, 3)
# Scree Plot 상으로는 눈에 띄는 elbow point가 관찰되지는 않는다.
# 기여율을 확인해보았을때 인자 개수를 2개로 정한다면
# 총 기여율은 39.838 + 27.351 + 17.283 = 67.189% 이다.
# 변수의 개수가 많지 않아 더이상 인자를 줄이는 것은 힘들어 보인다. (실제로 인자 3개로는 MLFA 코드가 오류로 작동되지 않음)
### Q2) 인자적재값과 인자적재그림을 통하여 인자를 해석하라.
library(psych)
Z = scale(X, scale=T)
pcfa = principal(Z, nfactors=2, rotate="none")
L = pcfa$loading[, 1:2]
round(L, 3)
Psi = pcfa$uniquenesses
Rm = R -(L %*% t(L) + diag(Psi))
round(Rm, 3)
### Residual matrix에서 특정 몇몇 원소들을 제외하고는 0에
### 가까운 값이므로 선택한 인자 2개가 모든 변수들을 어느 정도 잘 설명한다고 할 수 있다.
pcfa
### RMSR 값이 0.15이고 새로운 인자 2개의 cumulative variance가 1번 문제에서 확인했듯이  0.67(=67%)임을 알 수 있다.
lim = range(pretty(L))
par(family="AppleGothic")
plot(L[,1], L[,2],main="Plot of Factor Loadings(f1 & f2) : none ",  xlab="f1", ylab="f2",
xlim=lim, ylim=lim)
text(L[,1], L[, 2], labels=rownames(L), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L[,1], L[, 2], col=2, code=2, length=0.1)
### 회전시키기 전 인자적재그림은 직관적인 해석이 어려워보이므로, varimax 회전을 통한 그림을 확인해보자.
pcfa_rotate = principal(Z, nfactors=2, rotate="varimax")
L_rotate = pcfa_rotate$loading[, 1:2]
round(L_rotate, 3)
lim_rotate = range(pretty(L_rotate))
par(family="AppleGothic")
plot(L_rotate[,1], L_rotate[,2],main="Plot of Factor Loadings(f1 & f2) : varimax ",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
# f1(RC1)은 변수와 축이 이루는 각도를 고려해보았을때, 주택가격과 전문가비율이 큰 양의 관계를 갖는다고 할 수 있다. 즉, 주택가격 인자나 전문가 비율인자라고 할 수 있다.
# f2(RC2)는 취업율이 큰 양의 관계를 갖는다고 할 수 있다. 즉, 취업율 인자라고 할 수 있다.
# 총인구수의 경우에는 각도는 좁지만 길이가 짧기 때문에 취업율보다 더 작은 양의 관계를 갖는다.
# 실제로 이루는 각도가 더 넓은 공무원비율이 길이가 더 길어 인자적재값이 비슷하게 나옴을 알 수 있다.
# 또한 길이도 길고 서로 이루는 각도도 좁은 주택가격과 전문가 비율은 양의 상관관계를 가질것이다. (실제 상관계수값 : 0.685로 높음)
# 개인적인 해석으로는 첫번째 인자가 고소득 지역을 나타내는 인자라고 볼 수 있을것 같다.
# 두번째 인자는 첫번째 인자보다는 해석이 어렵지만 인구수가 많고 취업율이 높고, 공무원 비율은 낮다고 할 수 있으므로
# 인구가 밀집되어 있는 공업단지 등을 대표하는 인자라고 생각해 볼 수도 있을 것 같다.
### Q3) 인자점수그림을 통해 형성된 군집의 특성을 살펴보라.
# 해석의 편리함을 위해 인자회전한 값에 대하여 인자 점수그림을 그린다.
fpc_rotate = pcfa_rotate$score
round(fpc_rotate, 3)
par(mfrow=c(1, 2))
lim_rotate = range(pretty(fpc_rotate))
plot(fpc_rotate[,1], fpc_rotate[,2],main="Factor Scores : f1 and f2",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc_rotate[,1], fpc_rotate[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
lim_rotate = range(pretty(L_rotate))
par(family="AppleGothic")
plot(L_rotate[,1], L_rotate[,2],main="Plot of Factor Loadings(f1 & f2) : varimax ",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
# 우측의 인자적재그림을 참고하면, 인자 점수그림의 1사분면에 위치한 지역들의 군집은
# 주택가격, 취업율, 총인구수 변수 관련 비슷한 특성을 갖는 그룹임을 알 수 있다.
# 2사분면의 경우에는 뻗어져있는 변수가 없으므로, 변수들과 크게 연관성을 찾기 힘든 지역들의 군집임을 알 수 있다. (이는 3사분면도 마찬가지 이다)
# 4사분면의 경우에는 전문가비율, 공무원 비율이 뻗어져 있으므로 이들 변수간의 관계가 크고 유사한 지역들의 군집임을 알 수 있다.
# 간단하게 예시를 확인해보자.
X[45:50, ]
# 실제로 전문가비율 방향으로 분포되어 있는 48번과 49번 지역은 전문가 비율이 다른지역에 비해 매우 높고,
# 공무원 비율 방향으로 크게 뻗어져있는 47번 지역은 공무원 비율이 다른 지역에 비해 매우 높다.
### Q4) (1)의 인자개수에 대해 MLFA를 실시하고 (2)~(3)을 시행한 후에 결과를 서로 비교하라.
mlfa = factanal(Z, factors=2, rotation="varimax")
mlfa
Lm_MLFA = mlfa$loadings[, 1:2]
round(Lm_MLFA, 3)
Psi_MLFA = mlfa$uniquenesses
Rm_MLFA = R - (Lm_MLFA %*% t(Lm_MLFA) + diag(Psi))
round(Rm_MLFA, 3) # Residual matrix
# PCFA의 결과와 비교했을때 잔차행렬의 비대각원소들이 더욱 더 0에 가까우므로, PCFA보다 MLFA가 더욱 더 합리적인 분석을 하였다고 할 수 있다.
round(Rm, 3)
Lm_MLFA = mlfa$loadings[, 1:2]
round(Lm_MLFA, 3)
Psi_MLFA = mlfa$uniquenesses
Rm_MLFA = R - (Lm_MLFA %*% t(Lm_MLFA) + diag(Psi_MLFA))
round(Rm_MLFA, 3) # Residual matrix
round(Rm, 3)
round(Lm_MLFA, 3)
round(Lm, 3)
round(L, 3) # PCFA
round(L_rotate, 3) # PCFA
round(Lm_MLFA, 3) # MLFA
round(L_rotate, 3) # PCFA
par(mfrow=c(1,2))
par(family="AppleGothic")
lim_MLFA = range(pretty(Lm_MLFA))
plot(Lm_MLFA[,1], L_rotate[,1],main="Plot of Factor Loadings : ml f1 and pc f1",  xlab="ml f1", ylab="fc f2",
xlim=lim_MLFA, ylim=lim_rotate)
text(Lm_MLFA[,1], L_rotate[, 1], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, Lm_MLFA[,1], L_rotate[, 1], col=2, code=2, length=0.1)
par(mfrow=c(1,2))
par(family="AppleGothic")
lim_MLFA = range(pretty(Lm_MLFA))
plot(Lm_MLFA[,1], L_rotate[,1],main="Plot of Factor Loadings : ml f1 and pc f1",  xlab="ml f1", ylab="fc f1",
xlim=lim_MLFA, ylim=lim_rotate)
text(Lm_MLFA[,1], L_rotate[, 1], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, Lm_MLFA[,1], L_rotate[, 1], col=2, code=2, length=0.1)
par(mfrow=c(1,2))
par(family="AppleGothic")
lim_MLFA = range(pretty(Lm_MLFA))
plot(Lm_MLFA[,1], L_rotate[,1],main="Plot of Factor Loadings : ml f1 and pc f1",  xlab="ml f1", ylab="fc f1",
xlim=lim_MLFA, ylim=lim_rotate)
text(Lm_MLFA[,1], L_rotate[, 1], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, Lm_MLFA[,1], L_rotate[, 1], col=2, code=2, length=0.1)
par(mfrow=c(1,2))
par(family="AppleGothic")
lim_MLFA = range(pretty(Lm_MLFA))
plot(Lm_MLFA[,1], L_rotate[,1],main="Plot of Factor Loadings : ml f1 and pc f1",  xlab="ml f1", ylab="fc f1",
xlim=lim_MLFA, ylim=lim_rotate)
text(Lm_MLFA[,1], L_rotate[, 1], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, Lm_MLFA[,1], L_rotate[, 1], col=2, code=2, length=0.1)
library(MVN)
mvn(Z)
mvn(Z, type="mardia")
mvn(Z, multivariatePlot = ="mardia")
/mvn
/=?mvn
?mvn
mvn(Z, mvnTest = ="mardia")
mvn(Z, mvnTest ="mardia")
mvn(X, mvnTest ="mardia")
mlfa
mlfa$cumulative
mlfa
# 총 기여율은57.6%로 PCFA의 약 67%에 비해 설명력이 낮아졌다고 할 수 있다.
Psi_MLFA
Psi_rotate
Psi
Psi_MLFA = mlfa$uniquenesses
Rm_MLFA = R - (Lm_MLFA %*% t(Lm_MLFA) + diag(Psi_MLFA))
round(Rm_MLFA, 3) # Residual matrix
round(Rm, 3)
mlfa
round(Rm_MLFA, 3) # Residual matrix
round(Rm, 3)
Rm_rotate = R -(L_rotate %*% t(L_rotate) + diag(pcfa_rotate$uniquenesses))
round(Rm_MLFA, 3) # Residual matrix
round(Rm_rotate, 3)
par(mfrow=c(1,2))
par(family="AppleGothic")
lim_MLFA = range(pretty(Lm_MLFA))
plot(Lm_MLFA[,1], Lm_MLFA[,2],main="Plot of ML Factor Loadings : f1 and f2",  xlab="ml f1", ylab="ml f2",
xlim=lim_MLFA, ylim=lim_MLFA)
text(Lm_MLFA[,1], Lm_MLFA[, 2], labels=rownames(Lm_MLFA), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, Lm_MLFA[,1], Lm_MLFA[, 2], col=2, code=2, length=0.1)
plot(L_rotate[,1], L_rotate[,2],main="Plot of Factor Loadings(f1 & f2) : varimax ",  xlab="f1", ylab="f2",
xlim=lim_rotate, ylim=lim_rotate)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
mlfa = factanal(Z, factors=2, rotation="varimax")
mlfa
Lm_MLFA = mlfa$loadings[, 1:2]
round(Lm_MLFA, 3) # MLFA
round(L_rotate, 3) # PCFA
Psi_MLFA = mlfa$uniquenesses
Rm_MLFA = R - (Lm_MLFA %*% t(Lm_MLFA) + diag(Psi_MLFA))
Rm_rotate = R -(L_rotate %*% t(L_rotate) + diag(pcfa_rotate$uniquenesses))
round(Rm_MLFA, 3) # Residual matrix
round(Rm_rotate, 3)
mlfa
par(mfrow=c(1,2))
par(family="AppleGothic")
lim_MLFA = range(pretty(Lm_MLFA))
plot(Lm_MLFA[,1], Lm_MLFA[,2],main="Plot of ML Factor Loadings : f1 and f2",  xlab="ml f1", ylab="ml f2",
xlim=lim_MLFA, ylim=lim_MLFA)
text(Lm_MLFA[,1], Lm_MLFA[, 2], labels=rownames(Lm_MLFA), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, Lm_MLFA[,1], Lm_MLFA[, 2], col=2, code=2, length=0.1)
plot(L_rotate[,1], L_rotate[,2],main="Plot of PC Factor Loadings : f1 and f2",  xlab="pc f1", ylab="pc f2",
xlim=lim_rotate, ylim=lim_rotate)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
# 총인구수의 경우 PCFA에서와 반대로 MLFA에서는 f1인자에 음의 영향을 준다.
fml = mlfa$scores
round(fml, 3)
fml
# 다변량 정규성은 만족하지 않는 것을 알 수 있다.
mlfa = factanal(Z, factors=2, rotation="varimax", score="regression")
mlfa
Lm_MLFA = mlfa$loadings[, 1:2]
round(Lm_MLFA, 3) # MLFA
round(L_rotate, 3) # PCFA
Psi_MLFA = mlfa$uniquenesses
Rm_MLFA = R - (Lm_MLFA %*% t(Lm_MLFA) + diag(Psi_MLFA))
Rm_rotate = R -(L_rotate %*% t(L_rotate) + diag(pcfa_rotate$uniquenesses))
round(Rm_MLFA, 3) # Residual matrix
round(Rm_rotate, 3)
mlfa
par(mfrow=c(1,2))
par(family="AppleGothic")
lim_MLFA = range(pretty(Lm_MLFA))
plot(Lm_MLFA[,1], Lm_MLFA[,2],main="Plot of ML Factor Loadings : f1 and f2",  xlab="ml f1", ylab="ml f2",
xlim=lim_MLFA, ylim=lim_MLFA)
text(Lm_MLFA[,1], Lm_MLFA[, 2], labels=rownames(Lm_MLFA), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, Lm_MLFA[,1], Lm_MLFA[, 2], col=2, code=2, length=0.1)
plot(L_rotate[,1], L_rotate[,2],main="Plot of PC Factor Loadings : f1 and f2",  xlab="pc f1", ylab="pc f2",
xlim=lim_rotate, ylim=lim_rotate)
text(L_rotate[,1], L_rotate[, 2], labels=rownames(L_rotate), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
arrows(0,0, L_rotate[,1], L_rotate[, 2], col=2, code=2, length=0.1)
fml = mlfa$scores
round(fml, 3)
par(mfrow=c(2,2))
par(pty="s")
lim_rotate = range(pretty(fpc_rotate))
plot(fpc_rotate[,1], fpc_rotate[,2],main="Factor Scores : f1 and f2",  xlab="pc f1", ylab="pc f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc_rotate[,1], fpc_rotate[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
par(mfrow=c(1,2))
par(pty="s")
par(family="AppleGothic")
lim_fml = range(pretty(fml))
plot(fml[,1], fml[,2],main="Plot of ML Factor Scores : f1 and f2",  xlab="ml f1", ylab="ml f2",
xlim=lim_fml, ylim=lim_fml)
text(fml[,1], fml[, 2], labels=rownames(Lm_MLFA), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
lim_rotate = range(pretty(fpc_rotate))
plot(fpc_rotate[,1], fpc_rotate[,2],main="Factor Scores : f1 and f2",  xlab="pc f1", ylab="pc f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc_rotate[,1], fpc_rotate[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
par(mfrow=c(1,2))
par(pty="s")
par(family="AppleGothic")
lim_fml = range(pretty(fml))
plot(fml[,1], fml[,2],main="Plot of ML Factor Scores : f1 and f2",  xlab="ml f1", ylab="ml f2",
xlim=lim_fml, ylim=lim_fml)
text(fml[,1], fml[, 2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
lim_rotate = range(pretty(fpc_rotate))
plot(fpc_rotate[,1], fpc_rotate[,2],main="Factor Scores : f1 and f2",  xlab="pc f1", ylab="pc f2",
xlim=lim_rotate, ylim=lim_rotate)
text(fpc_rotate[,1], fpc_rotate[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
par(pty="s")
par(mfrow=c(1,2))
plot(fml[,1], fpc_rotate[,1], main="Factor Scores : ml f1 and pc f1", xlab="ml f1", ylab="pc f1",
xlim=lim_fml, ylim=lim_rotate)
text(fml[,1], fpc_rotate[,1], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
plot(fml[,2], fpc_rotate[,2], main="Factor Scores : ml f2 and pc f2", xlab="ml f2", ylab="pc f2",
xlim=lim_fml, ylim=lim_rotate)
text(fml[,2], fpc_rotate[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
par(pty="s")
par(mfrow=c(1,2))
plot(fml[,1], fpc_rotate[,1], main="Factor Scores : ml f1 and pc f1", xlab="ml f1", ylab="pc f1",
xlim=lim_fml, ylim=lim_rotate)
text(fml[,1], fpc_rotate[,1], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
plot(fml[,2], fpc_rotate[,2], main="Factor Scores : ml f2 and pc f2", xlab="ml f2", ylab="pc f2",
xlim=lim_fml, ylim=lim_rotate)
text(fml[,2], fpc_rotate[,2], labels=rownames(X), cex=0.8, col="blue", pos=1)
abline(v=0, h=0)
### Q5) 인자행렬도를 통해 인자와 개체 간의 연관성을 살펴보라.
Lt = pcfa_rotate$loadings[, 1:2]
Ft = pcfa_rotate$scores
### Q5) 인자행렬도를 통해 인자와 개체 간의 연관성을 살펴보라.
Lt = pcfa_rotate$loadings[, 1:2]
Ft = pcfa_rotate$scores
lim1 = range(pretty(Lt))
lim2 = range(pretty(Ft))
### Q5) 인자행렬도를 통해 인자와 개체 간의 연관성을 살펴보라.
Lt = pcfa_rotate$loadings[, 1:2]
Ft = pcfa_rotate$scores
lim1 = range(pretty(Lt))
lim2 = range(pretty(Ft))
biplot(Ft, Lt, xlab="f1", ylab="f2", main="Rotated Biplot", xlim=lim2, ylim=lim2, cex=0.8, pch=16)
abline(v=0, h=0)
par(mfrow=c(1,1))
biplot(Ft, Lt, xlab="f1", ylab="f2", main="Rotated Biplot", xlim=lim2, ylim=lim2, cex=0.8, pch=16)
abline(v=0, h=0)
X[23:25]
X[23:25,]
View(X)
