# Example of PCA
## Calculating eigenvectors and eigenvalues.
V1 = c(1.63, -0.40, 0.93, -1.38, -0.17, -0.61)
V2 = c(1.22, 0.79, 0.97, -1.08, -0.96, -0.93)
plot(V1, V2, xlim=c(-2, 2), ylim=c(-2, 2), col="red", pch=15)
par(mfrow=c(1,1))
plot(V1, V2, xlim=c(-2, 2), ylim=c(-2, 2), col="red", pch=15)
Z = matrix(c(V1, V2), nrow=6, byrow=FALSE)
cor(Z)
e = eigen(cor(Z))
e
Z %*% e$vec[,1]
Score = Z %*% e$vec
colnames(Score) = c("PC1", "PC2")
Score
## Using built-in function.
pca = princomp(Z, cor=TRUE)
pca$scores
pca$loadings
pvar = pca$sdev^2
pvar
pve = pvar/sum(pvar)
pve
e
## Application to the Golub data.
data(golub, package="multtest")
cgolub = cor(golub)
dim(cgolub)
e = eigen(cgolub)
dim(e$vector)
e$values
plot(e$values, type="b", pch=19, col=2, ylab="eigenvalues",
xlab="the number of components")
## bootstrap C.I for the eigenvalues.
n = ncol(golub)
p = nrow(golub)
B = 10000
set.seed(10101)
eval = matrix(0, B, n)
for (i in 1:B) {
index = sample(1:p, replace=TRUE)
boot = golub[index,]
eval[i, ] = eigen(cor(boot))$values
}
CI = apply(eval, 2, function(t) quantile(t, c(0.025, 0.975)))
t(CI)
# Example of Biplot
## Biplot displays both the principal component scores and the principal component loadings.
biplot(princomp(golub, cor=TRUE), pc.biplot=TRUE, cex=0.5,
expand=0.8, xlab="Component 1", ylab="Component 2")
gFactor = factor(golub.cl, levels=0:1, labels=c("ALL","AML"))
meanALL = apply(golub[ ,gFactor=="ALL"], 1, mean)
meanAML = apply(golub[ ,gFactor=="AML"], 1, mean)
o = order(abs(meanALL - meanAML), decreasing=TRUE)
DE50 = golub[o[1:50], ]
g50 = princomp(DE50, cor=TRUe)
g50 = princomp(DE50, cor=TRUE)
biplot(g50, pc.biplot=TRUE, cex=0.5, expand=0.8,
xlab="Component 1", ylab="Component 2")
abline(v=0, col="grey", lty=2)
abline(h=0, col="grey", lty=2)
# Example of Clustering with PCA
## Genes critical for S-phase.
golubFactor = factor(golub.cl)
o1 = grep("CD", golub.gnames[ ,2])
o2 = grep("Op", golub.gnames[ ,2])
o3 = grep("MCM", golub.gnames[ ,2])
o = c(o1, o2, o3)
length(o)
fun = function(x) t.test(x ~ golubFactor)$p.value
pt = apply(golub[o, ], 1, fun)
oo = o[pt < 0.01]
length(oo)
## we use the scores on the first two PC.
pca = princomp(golub)
leu = data.frame(pca$scores[oo, 1:2], row.names=oo)
plot(leu, xlim=c(-10, 15), ylim=c(-10, 10), pch=19, cex=1.2,
xlab="Principal Component 1", ylab="Principal Component 2",
col="darkgreen")
text(x=leu[, 1], y=leu[ ,2], labels=rownames(leu), pos=1,
col="blue", cex=0.6)
abline(h=0, col="grey", lty=2)
abline(v=0, col="grey", lty=2)
fac = rep(1, length(oo))
fac[oo %in% o2] = 2
fac[oo %in% o3] = 3
text(x = leu[, 1], y=leu[, 2], labels=fac, pos=3, col="red")
fac = rep(1, length(oo))
fac
fac[oo %in% o2] = 2
fac
fac[oo %in% o3] = 3
text(x = leu[, 1], y=leu[, 2], labels=fac, pos=3, col="red")
# Hierarchical Cluster using PCA
dist = dist(leu, method="euclidean")
cl = hclust(dist, method="single")
x11()
plot(cl, lwd=3, col="blue", col.axis = "brown", ylab="Distance",
xlab="Clustering of the expression of genes",
hang=-1, main=NA, sub=NA, axes=FALSE)
axis(side=2, at=seq(0,5,1), col="brown", labels=TRUE, lwd = 4)
a = as.integer(rownames(leu)[cl$order])
golub.gnames[a, 2]
data(golub, package="multtest")
cyclins = grep("Cyclin", golub.gnames[, 2])
cyclins = grep("Cyclin", golub.gnames[, 2])
cyclins = grep("Cyclin", golub.gnames[, 2])
cyclins = grep("Cyclin", golub.gnames[, 2])
cyclins = grep("Cyclin", golub.gnames[, 2])
cyclins = grep("Cyclin", golub.gnames[, 2])
cyclins = grep("Cyclin", golub.gnames[, 2])
golub.gnames[cyclins, 2]
golub[cyclins, ]
dist.cyclin = dist(golub[cyclins, ], method="euclidean")
dist.cyclin
dim(golub[cyclins, ])
dist.cyclin
dim(dist.cyclin)
dim(golub[cyclins,])
distanceMatrix = as.matrix(dist.cyclin)
golub.gnames[cyclins, 3]
golub.gnames[cyclins, 2]
distanceMatrix = as.matrix(dist.cyclin)
rownames(distanceMatrix) = golub.gnames[cyclins, 3]
colnames(distanceMatrix) = golub.gnames[cyclins, 3]
distanceMatrix[1:5, 1:5]
set.seed(111)
x1 = matrix(rnorm(100, 0, 0.5), ncol=2)
x2 = matrix(rnorm(100, 2, 0.5), ncol=2)
data = rbind(x1, x2)
cl = kmeans(data, 2, nstart=20)
cl
plot(data, col=cl$cluster, pch=19, xlab="", ylab="",
main="K-Means Clustering Results with K=2")
points(cl$centers, col=1:2, pch=8, cex=4)
cl = kmeans(data, 3, nstart=20)
plot(data, col=cl$cluster, pch=19, xlab="", ylab="",
main="K-Means Clustering Results with K=3")
points(cl$centers, col=1:3, pch=8, cex=4)
set.seed(111)
par(mfrow=c(1,2))
cl = kmeans(data, 3, nstart=1)
tv = round(cl$tot.withinss, 3)
plot(data, col=cl$cluster, pch=19, xlab="", ylab="",
main=paste("(", tv, ")"))
points(cl$centers, col=1:3, pch=8, cex=4)
cl = kmeans(data, 3, nstart=20)
tv = round(cl$tot.withinss, 3)
plot(data, col=cl$cluster, pch=19, xlab="", ylab="",
main=paste("(", tv, ")"))
points(cl$centers, col=1:3, pch=8, cex=4)
par(mfrow=c(1,1))
data(golub, package="multtest")
zyxin = grep("Zyxin", golub.gnames[, 2])
ccnd3 = grep("CCND3", golub.gnames[, 2])
data = data.frame(golub[ccnd3, ], golub[zyxin, ])
colnames(data) = c("CCND3 (Cyclin D3)", "Zyxin")
cl = kmeans(data, 2, nstart=20)
cbind(cl$cluster, golub.cl)
plot(data, col=cl$cluster, pch=19, xlab="", ylab="")
points(cl$centers, col=1:2, pch=8, cex=4)
par(mfrow=c(1, 3))
cl = kmeans(data, 2, nstart=20)
plot(data, col=cl$cluster, pch=19, xlab="", ylab="",
main="K = 2")
points(cl$centers, col=1:2, pch=8, cex=4)
cl = kmeans(data, 3, nstart=20)
plot(data, col=cl$cluster, pch=19, xlab="", ylab="",
main="K = 3")
points(cl$centers, col=1:3, pch=8, cex=4)
cl = kmeans(data, 4, nstart=20)
plot(data, col=cl$cluster, pch=19, xlab="", ylab="",
main="K = 4")
points(cl$centers, col=1:4, pch=8, cex=4)
names = list(c("g1", "g2", "g3", "g4", "g5"), c("patient 1", "patient 2"))
sl = matrix(c(1, 1, 1, 1.3, 3, 2, 3, 2.4, 5, 5), ncol=2, byrow=TRUE, dimnames=names)
rr = c(0, 6)
par(mfrow=c(1,1))
plot(sl, pch=19, col="blue", cex=1.5, xlim=rr, ylim=rr)
text(sl, labels=row.names(sl), pos=4, col="red", cex=1.2)
print(dist(sl, method="euclidian"), digits=3)
ds = dist(sl, method="euclidean")
sl.out = hclust(ds, method="single")
sl.out
plot(sl.out, lwd=3, col="blue", col.axis = "brown",
hang=-1, main=NA, sub=NA, axes=FALSE, ylab="Distance",
xlab="Clustering of the expression of 5 genes")
axis(side=2, at=seq(0,3.5,.5), col="brown", labels=TRUE, lwd=4)
set.seed(12345)
x = rnorm(20)
out = hclust(dist(x, method="euclidean"), method="single")
plot(out, lwd=3, col="blue", hang=-1, main=NA, sub=NA, axes=FALSE, ylab="Distance",
xlab="20 genes with normal random distances")
axis(side=2, at=seq(0, 1.4, .2), col="brown", labels=TRUE, lwd=4)
set.seed(4321)
x = c(rnorm(10, 0, 0.1), rnorm(10, 3, 0.5), rnorm(10, 10, 1.0))
out = hclust(dist(x, method="euclidean"), method="single")
plot(out, lwd=3, col="blue", hang=-1, main=NA, sub=NA,
axes=FALSE, ylab="Distance",
xlab="3 clusters of 10 genes each")
axis(side=2, at=seq(0, 5, 1), col="brown", labels=TRUE, lwd=4)
abline(h=1, lty=2, lwd=2, col="gray")
data(golub, package="multtest")
zyxin = grep("Zyxin", golub.gnames[, 2])
ccnd3 = grep("CCND3", golub.gnames[ , 2])
clusdata = data.frame(golub[ccnd3, ], golub[zyxin, ])
colnames(clusdata) = c("CCND3 Cyclin D3", "Zyxin")
gfactor = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
gf = as.numeric(gfactor)
plot(clusdata, pch=gf+15, col=gf+1)
legend("topright", legend=c("ALL", "AML"), pch=16:17, col=c(2, 3))
dist.cl = dist(clusdata, method="euclidean")
gcl = hclust(dist.cl, method="single")
plot(gcl, lwd=3, col="blue", hang=-1, main=NA, sub=NA,
axes=FALSE, ylab="Distance",
xlab="Clustering of patients by gene expression")
axis(side=2, at=seq(0,1.2,.2), col="brown", labels=TRUE, lwd=4)
abline(h=0.6, lty=2, lwd=2, col="gray")
sort(rev(gcl$order)[1:9])
?rev
gcl$order[1:9]
rev(gcl$order[1:9])
which(gfactor=="AML")
par(mfrow=c(2,2))
hc1 = hclust(dist.cl, method="single")
plot(hc1, main="Single Linkage", xlab="", sub="", hang=-1)
abline(h=0.6, lty=2, col="blue")
hc2 = hclust(dist.cl, method="complete")
plot(hc2, main="Complete Linkage", xlab="", sub="", hang=-1)
abline(h=3, lty=2, col="orange")
hc3 = hclust(dist.cl, method="average")
plot(hc3, main="Average Linkage", xlab="", sub="", hang=-1)
abline(h=2.0, lty=2, col="green")
hc4 = hclust(dist.cl, method="centroid")
plot(hc4, main="Centroid Linkage", xlab="", sub="", hang=-1)
abline(h=1, lty=2, col="purple")
data(golub, package="multtest")
data(golub, package="multtest")
gFactor = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
meanALL = apply(golub[ , gFactor=="ALL"], 1, mean)
meanAML = apply(golub[ , gFactor=="AML"], 1, mean)
o = order(abs(meanALL - meanAML), decreasing=TRUE)
DE50 = golub[o[1:50], ]
par(mfrow=c(1,1))
hist(DE50, nclass=50, col="orange") # Top 50 which is far from mean
library(gplots)
heatmap.2(DE50, Rowv=NA, Colv=NA, scale="row", cexRow=0.5,
col=greenred(75), dendrogram="none", key=TRUE,
symkey=FALSE, density.info="none", trace="none")
## Next, we enhance our "Top 50 Genes" heatmap by performing heirarchical clustering on both rows and columns.
heatmap.2(DE50, scale="row", col=greenred(75),
dendrogram="both", key=TRUE, symkey=FALSE,
density.info="none", trace="none", cexRow=0.5)
dev.off()
library(gplots)
heatmap.2(DE50, Rowv=NA, Colv=NA, scale="row", cexRow=0.5,
col=greenred(75), dendrogram="none", key=TRUE,
symkey=FALSE, density.info="none", trace="none")
## Next, we enhance our "Top 50 Genes" heatmap by performing heirarchical clustering on both rows and columns.
heatmap.2(DE50, scale="row", col=greenred(75),
dendrogram="both", key=TRUE, symkey=FALSE,
density.info="none", trace="none", cexRow=0.5)
data(golub, package="multtest")
mcm3 = grep("MCM3", golub.gnames[, 2])
golub.gnames[mcm3, ]
x = golub[mcm3[1], ]
y = golub[mcm3[2], ]
cor(x, y)
plot(x, y, pch=19, col="blue3")
abline(lm(y ~ x)$coef, col=2, lty=2, lwd=2)
cor.test(x, y) # H0 : 상관계수=0 을 기각
B = 10000
per.cor = NULL
for (i in 1:B) {
index1 =  sample(1:length(x))
index2 = sample(1:length(y))
per.cor[i] = cor(x[index1], y[index2])
}
hist(per.cor, nclass=50, col="orange")
c0 = cor(x, y)
abline(v=c(-c0, c0), lty=2, lwd=2, col="blue")
c0
hist(per.cor, nclass=50, col="orange")
c0 = cor(x, y)
abline(v=c(-c0, c0), lty=2, lwd=2, col="blue")
cor.test(x, y)
(sum(abs(per.cor) > abs(c0)) + 1) / (B + 1) # p-value
B = 10000
boot.cor = rep(0, B)
data = cbind(x, y)
set.seed(1)
for (i in 1:B) {
index = sample(1:nrow(data), replace=TRUE)
dat.star = data[index, ]
boot.cor[i] = cor(dat.star)[1, 2]
}
hist(boot.cor, nclass=50, col="orange")
CI = quantile(boot.cor, c(0.025, 0.975))
abline(v=CI, lty=2, lwd=2, col="blue")
mean(boot.cor)
CI
y = golub.cl
y
corgol = apply(golub, 1, function(x) cor(x, y))
corgol
o = order(abs(corgol), decreasing=TRUE)
top = 10
ot = o[1:top]
data.frame(genes=golub.gnames[ot, 3], cor=corgol[ot])
par(mfrow=c(1, 2))
par(mfrow=c(1, 2))
hist(corgol, nclass=20, col="orange", xlab="", main="PCC")
hist(fstat, nclass=20, col="lightblue", xlab="",
main="F test statistic")
par(mfrow=c(1, 2))
fun = function(x) summary(lm(x ~ y))$fstat[1] # overall F-test : H0: beta_1 = 0, F-statistic high => reject H0
fstat = apply(golub, 1, fun)
o2 = order(fstat, decreasing=TRUE)
top = 10
ot2 = o2[1:top]
data.frame(genes=golub.gnames[ot2, 3], f.stat=fstat[ot2])
par(mfrow=c(1, 2))
hist(fstat, nclass=20, col="lightblue", xlab="",
main="F test statistic")
par(mfrow=c(1, 2))
hist(corgol, nclass=20, col="orange", xlab="", main="PCC")
hist(fstat, nclass=20, col="lightblue", xlab="",
main="F test statistic")
V1 = c(1.63, -0.40, 0.93, -1.38, -0.17, -0.61)
V2 = c(1.22, 0.79, 0.97, -1.08, -0.96, -0.93)
par(mfrow=c(1,1))
plot(V1, V2, xlim=c(-2, 2), ylim=c(-2, 2), col="red", pch=15)
Z = matrix(c(V1, V2), nrow=6, byrow=FALSE)
cor(Z)
Z
e = eigen(cor(Z))
e
Z = %*% e$vec[, 1]
Z %*% e$vec[, 1]
Score = Z %*% e$vec
colnames(Score) = c("PC1", "PC2")
Score
pca = princomp(Z, cor=TRUE)
pca$scores
pca$loadings
pvar = pca$sdev^2
pvar
pve = pvar/sum(pvar)
pve
pca
data(golub, package="multtest")
cgolub = cor(golub)
dim(cgolub)
e = eigen(cgolub)
dim(e$vector)
e$values
plot(e$values, type="b", pch=19, col=2, ylab="eigenvalues",
xlab="the number of components")
n = ncol(golub)
p = nrow(golub)
B = 10000
set.seed(10101)
eval = matrix(0, B, n)
for (i in 1:B) {
index = sample(1:p, replace=TRUE)
boot = golub[index,]
eval[i, ] = eigen(cor(boot))$values
}
CI = apply(eval, 2, function(t) quantile(t, c(0.025, 0.975)))
t(CI)
golubFactor = factor(golub.cl)
o1 = grep("CD", golub.gnames[ ,2])
o2 = grep("Op", golub.gnames[ ,2])
o3 = grep("MCM", golub.gnames[ ,2])
o = c(o1, o2, o3)
length(o)
fun = function(x) t.test(x ~ golubFactor)$p.value
pt = apply(golub[o, ], 1, fun)
oo = o[pt < 0.01]
length(oo)
pca = princomp(golub)
leu = data.frame(pca$scores[oo, 1:2], row.names=oo)
plot(leu, xlim=c(-10, 15), ylim=c(-10, 10), pch=19, cex=1.2,
xlab="Principal Component 1", ylab="Principal Component 2",
col="darkgreen")
text(x=leu[, 1], y=leu[ ,2], labels=rownames(leu), pos=1,
col="blue", cex=0.6)
abline(h=0, col="grey", lty=2)
abline(v=0, col="grey", lty=2)
fac = rep(1, length(oo))
fac[oo %in% o2] = 2
fac[oo %in% o3] = 3
text(x = leu[, 1], y=leu[, 2], labels=fac, pos=3, col="red")
leu
dist = dist(leu, method="euclidean")
cl = hclust(dist, method="single")
x11()
plot(cl, lwd=3, col="blue", col.axis = "brown", ylab="Distance",
xlab="Clustering of the expression of genes",
hang=-1, main=NA, sub=NA, axes=FALSE)
axis(side=2, at=seq(0,5,1), col="brown", labels=TRUE, lwd = 4)
x11()
plot(cl, lwd=3, col="blue", col.axis = "brown", ylab="Distance",
xlab="Clustering of the expression of genes",
hang=-1, main=NA, sub=NA, axes=FALSE)
axis(side=2, at=seq(0,5,1), col="brown", labels=TRUE, lwd = 4)
a = as.integer(rownames(leu)[cl$order])
golub.gnames[a, 2]
A = 100
B = 200
a = 20
b = 40
(a-b)/A
(b-a)/A * 100
a = 30
(b-a)/A * 100
data(golub, package="multtest")
Labels = factor(golub.cl, levels=0:1, labels=c("ALL", "notALL"))
ccnd3 = grep("CCND3", golub.gnames[,2], ignore.case=TRUE)
decision = golub[ccnd3, ] > 1.27
decision
c(sum(decision), ncol(golub))
Pred = factor(decision, levels=c("TRUE", "FALSE"), labels=c("ALL", "notALL"))
table(Labels, Pred)
tab = table(Labels, Pred)
sensitivity = tab[1, 1] / sum(tab[1, ])
sensitivity
specificity = tab[2, 2] / sum(tab[2, ])
PV.positive = tab[1, 1] / sum(tab[ ,1])
tab[, 1]
PV.negative = tab[2, 2] / sum(tab[, 2])
c(sensitivity, specificity, PV.positive, PV.negative)
decision = golub[ccnd3, ] > 2.18
Pred = factor(decision, levels=c("TRUE", "FALSE"), labels=c("ALL", "notALL"))
tab = table(Labels, Pred)
sensitivity = tab[1, 1] / sum(tab[1, ])
specificity = tab[2, 2] / sum(tab[2, ])
PV.positive = tab[1, 1] / sum(tab[ ,1])
PV.negative = tab[2, 2] / sum(tab[, 2])
c(sensitivity, specificity, PV.positive, PV.negative)
decision = golub[ccnd3, ] > 0.4
Pred = factor(decision, levels=c("TRUE", "FALSE"), labels=c("ALL", "notALL"))
tab = table(Labels, Pred)
sensitivity = tab[1, 1] / sum(tab[1, ])
specificity = tab[2, 2] / sum(tab[2, ])
PV.positive = tab[1, 1] / sum(tab[ ,1])
PV.negative = tab[2, 2] / sum(tab[, 2])
c(sensitivity, specificity, PV.positive, PV.negative) # bad cutoff
sort(golub[ccnd3, Labels=="ALL"], decreasing=TRUE)
sort(golub[ccnd3, Labels!="ALL"], decreasing=TRUE)
# Example of ROC Curve
install.packages("ROCR")
library(ROCR)
true = factor(golub.cl, levels=0:1, labels=c("TRUE", "FALSE"))
predccnd3 = prediction(golub[ccnd3, ], true)
perfccnd3 = performance(predccnd3, "tpr", "fpr")
plot(perfccnd3, lwd=4, col="blue")
perfccnd3
predccn3
predccnd3
slotNames(perfccnd3)
list(perfccnd3@x.name, perfccnd3@x.values)
perfccnd3@x.name
list(perfccnd3@y.name, perfccnd3@y.values) # False positive rate
list(perfccnd3@alpha.name, perfccnd3@alpha.values)
performance(predccnd3, "auc")@y.values
gdf5 = grep("GDF5", golub.gnames[, 2], ignore.case=TRUE)
predgdf5 = prediction(golub[gdf5, ], true)
perfgdf5 = performance(predgdf5, "tpr", "fpr")
plot(perfgdfr5, lwd=4, col="magenta")
plot(perfgdf5, lwd=4, col="magenta")
## We can improve Gdf5-classifier by reversing the classification labels
true2 = factor(golub.cl, levels=0:1, labels=c("FALSE", "TRUE"))
predgdf5 = prediction(golub[gdf5, ], true2)
perfgdf5 = performance(predgdf5, "tpr", "fpr")
performance(predgdf5, "auc")@y.values
plot(perfgdf5, lwd=4, col="magenta")
plot(perfccnd3, lwd=4, col="blue", add=TRUE)
## Still low performance, because ccnd3 is a biomarker for ALL, but Gdf5 is not.
data(golub, package="multtest")
# Example of Logistic Regression
data(golub, package="multtest")
Factor = factor(golub.cl, levels=0:1, labels=c("ALL", "AML"))
ccnd3 = grep("CCND3", golub.gnames[, 2], ignore.case=TRUE)
g = glm(Factor ~ golub[ccnd3, ], family=binomial)
summary(g)
summary(g)
summary(g)$coef
pchisq(deviance(g), df.residual(g), lower=FALSE) # not reject H0 => model well fitted!
## predictive accuracy
eta = cbind(1, golub[ccnd3, ]) %*% g$coef
exp(eta) / (1 + exp(eta))
eta
exp(eta) / (1 + exp(eta))
predict(g, type="response")
x = golub[ccnd3, ]
y = 1 - golub.cl
u = order(x)
plot(x, y, pch="|", col="orange", ylim=c(-0.1,1.1),
xlab="Gene expression values", ylab="Probability of ALL")
abline(h=c(0, 1), lty=2)
points(x[u], 1-g$fit[u], col="blue", lwd=2, pch=20)
pred = predict(g, type="response") < 0.5 # 0.5 ; threshold, 이 값이 변화하는 것에 따른 sensitivity, specifity 를 관찰하는게 ROC curve
est = factor(pred, levels=c(TRUE, FALSE), labels=c("ALL", "not ALL"))
table(est, Factor)
library(ROCR)
true = factor(golub.cl, levels=0:1, labels=c("FALSE", "TRUE"))
yprob = predict(g, type="response")
pred = prediction(yprob, true)
perf = performance(pred, "tpr", "fpr")
plot(perf, lwd=2, col="blue")
performance(pred, "auc")@y.values
